/*
Файл               : WndBtn.cpp

Проект             : Windows-приложение с использованием
стандартгых функций API-SDK (создается
главное окно, в него помещается сообщение и
кнопка, нажатие кнопки обрабатывается)

Microsoft Visual Studio C++ .NET 2005
*/

// Прекомпилируемый заголовочный файл
#include "stdafx.h"

// Прототипы используемых функций
LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam,
	LPARAM lParam);
BOOL InitApplication(HINSTANCE hInstance);
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow);

// Дескриптор кнопки (дочернего окна)
HWND                   hWnd1;

#define BTN1 1                      // Идентификатор кнопки

// ****************************************************************
// Главная функция приложения
int WINAPI WinMain(                 // Возвращает TRUE при успехе
									// Дескриптор данного приложения        
	HINSTANCE           hInstance,
	// Дескриптор предыдущей запущенной копии приложения. В
	//   Win32API этот параметр всегда равен NULL и оставлен
	//   исключительно для совместимости с версиями ниже четвертой.
	//   Связано это с тем, что каждое 32-разрядное приложение
	//   запускается в собственном адресном пространстве, в
	//   котором, естественно, нет никаких копий или других 
	//   приложений
	HINSTANCE           hPrevInstance,
	// Указатель на командную строку, которую можно в
	//   интегрированной среде разработки задать по команде
	//   "Properties" контекстного меню проекта в элементе "Program
	//   arguments" вкладки "Debugging"
	LPSTR               lpCmdLine,
	// Режим начального отображения главного окна приложения -
	//   после вызова параметр получает значение SW_SHOWNORMAL (1),
	//   что соответствует отображению окна в нормальном виде
	int                 nCmdShow)
{
	// Инициализируем приложение - подготавливаем данные класса
	//   окна и регистрируем его
	if (!InitApplication(hInstance))
		return FALSE;

	// Завершаем создание приложения - создаем и отображаем главное
	//   окно приложения
	if (!InitInstance(hInstance, nCmdShow))
		return FALSE;

	MSG                 msg;        // Для очередного сообщения
									// Стандартный цикл обработки сообщений
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return static_cast< int >(msg.wParam);
}

// ****************************************************************
BOOL InitApplication(               // Возвращает TRUE при успехе
									// Дескриптор (уникальное число), ассоциируемый с текущим
									//   приложением
	HINSTANCE           hInstance)
{
	// Сведения о регистрируемом классе
	WNDCLASS            wc;

	// Заполняем структуру класса окна WNDCLASS - смысл
	//   инициализирующих значений рассмотрен в проекте FrameWnd
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = static_cast< WNDPROC >(WndProc);
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = hInstance;
	wc.hIcon = LoadIcon(NULL, IDI_ASTERISK);
	wc.hCursor = LoadCursor(NULL, IDC_CROSS);
	wc.hbrBackground = reinterpret_cast< HBRUSH >(COLOR_WINDOW + 1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = "WndBtnAPI";

	// Регистрируем класс окна
	return RegisterClass(&wc);

	// !!! Класс окна для кнопки ("BUTTON") является стандартным и
	//   не требует специальной регистрации !!!

	return TRUE;
}

// ****************************************************************
// Создание главного окна приложения и кнопки
BOOL InitInstance(                  // Возвращает TRUE при успехе
									// Дескриптор текущего приложения 
	HINSTANCE           hInstance,
	// Режим отображения главного окна - определяет в каком виде
	//   будет отображено окно приложения
	int                 nCmdShow)
{
	// Дескриптор главного окна
	HWND                hWnd;

	// Создание главного окна приложения
	hWnd = CreateWindow(
		// Имя зарегистрированного класса
		"WndBtnAPI",
		// Заголовок окна
		"Создание приложения WndBtn с использованием "
		"Windows-SDK-API с текстом и кнопкой в главном окне",
		// Комбинированный стиль окна: WS_OVERLAPPED | WS_CAPTION |
		//   WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX |
		//   WS_MAXIMIZEBOX 
		WS_OVERLAPPEDWINDOW,        // Стиль окна
									// Горизонтальная координата левого верхнего угла окна
									//   (используется умалчиваемое значение)
		CW_USEDEFAULT,
		// Вертикальная координата левого верхнего угла окна
		//   (используется умалчиваемое значение)
		CW_USEDEFAULT,
		CW_USEDEFAULT,              // Ширина окна (используется
									//   умалчиваемое значение)
		CW_USEDEFAULT,              // Высота окна (используется
									//   умалчиваемое значение)
		NULL,                       // Дескриптор родительского
									//   окна (его нет)
		NULL,                       // Дескриптор меню окна (его
									//   нет)
		hInstance,                  // Дескриптор экземпляра
									//   приложения
		NULL);                     // Указатель на дополнительные
								   //   данные окна (их нет)
	if (!hWnd)
		return FALSE;

	// Показать окно: передает в Windows информацию (nCmdShow) о
	//   том, в каком виде необходимо отобразить окно. Значение
	//   этого аргумента можно выбирать по своему усмотрению
	if (ShowWindow(hWnd, nCmdShow))
		return FALSE;

	// Перерисовать окно: для перерисовки окна функция предписывает
	//   ОС Windows послать окну сообщение WM_PAINT
	if (!UpdateWindow(hWnd))
		return FALSE;

	// Создание кнопки. Здесь будьте внимательнее - это новая
	//   информация, которая отсутствовала в проекте FrameWnd
	hWnd1 = CreateWindow(
		// Имя зарегистрированного класса (в данном случае это
		//   стандартное имя)
		"BUTTON",
		"Кнопка",                   // Текст на кнопке
									// Стиль окна (WS_VISIBLE использовать обязательно), кнопка
									//   является дочерним окном
		WS_VISIBLE | WS_CHILD,
		// Горизонтальная координата левого верхнего угла кнопки
		210,
		// Вертикальная координата левого верхнего угла кнопки
		20,
		80,                         // Ширина кнопки
		20,                         // Высота кнопки
									// Дескриптор родительского окна
		hWnd,
		// Для кнопки - ее идентификатор (см. определение на
		//   внешнем уровне)
		reinterpret_cast< HMENU >(BTN1),
		// Дескриптор экземпляра приложения
		hInstance,
		// Указатель на дополнительные данные окна (они
		//   отсутствуют)
		NULL);
	if (!hWnd1)
	{
		MessageBox(NULL, "Кнопка не создана", "Ошибка 1", MB_OK);
		exit(1);
	}
	/*
	Наряду с использованием предопределенного имени оконного
	класса, в качестве еще одной особенности создания кнопки
	отметим возможность комбинирования обычных стилей окна,
	перечисленных в проекте FrameWnd, со специфическими стилями
	кнопок (в данном примере это, правда, не использовано).
	Существуют следующие стили кнопок.
	BS_3STATE
	Это стиль отмечаемой кнопки (checkbox), но окно может быть
	помечено или затемнено (показывая, что кнопка деактивирована)
	BS_AUTO3STATE
	Это стиль отмечаемой кнопки, но окно может быть помечено
	или затемнено (показывая, что кнопка деактивирована). Когда
	пользователь выбирает эту кнопку, ее состояние автоматически
	переключается
	BS_AUTOCHECKBOX
	Это стиль отмечаемой кнопки, но когда пользователь выбирает
	эту кнопку, автоматически включается ее отмеченное состояние
	BS_AUTORADIOBUTTON
	Это стиль радиокнопки. Когда пользователь выбирает эту
	кнопку, она помечается. При этом автоматически снимаются
	пометки с других кнопок того же стиля в той же группе
	BS_CHECKBOX
	Это стиль отмечаемой кнопки (небольшой квадрат с названием,
	расположенным с правой стороны по умолчанию или с левой
	стороны, если стиль совмещен со стилем)
	BS_DEFPUSHBUTTON
	Это стиль стандартной нажимаемой кнопки (кнопка с жироной
	темной рамкой), что дает возможность пользователю, нажимая на
	клавишу Enter, быстро выбирать команду по умолчанию
	BS_GROUPBOX
	Это стиль обрамляющего прямоугольника с названием для
	визуальной группировки элементов управления
	BS_LEFTTEXT
	В сочетании со стилями радиокнопки или отмечаемой кнопки
	этот стиль приводит к тому, что название кнопки располагается
	слева от нее самой
	BS_OWNERDRAW
	Стиль создает изображаемую пользователем кнопку. MFC
	автоматически вызывает метод DrawItem( ), когда кнопка
	изменяется визуально. Этот стиль чаще всего используется для
	кнопок класса CBitmapButton
	BS_PUSHBUTTON
	Стиль создает кнопку, посылающую сообщение WM_COMMAND окну-
	хозяину, когда пользователь ее нажимает
	BS_RADIOBUTTON
	Этот стиль создает радиокнопку (небольшой кружок с текстом
	с правой стороны по умолчанию или с левой, если стиль совмещен
	со стилем BS_LEFTTEXT). Кнопки этого стиля обычно используются
	в группе, чтобы обозначить связанные взаимоисключающие
	возможности
	BS_BITMAP
	Стиль создает кнопку с изображением рисунка
	BS_BOTTOM
	Стиль размещает текст кнопки внизу прямоугольника
	BS_CENTER
	Стиль выполняет горизонтальное центрирование текста в
	прямоугольнике
	BS_ICON
	Стиль создает кнопку с изображением пиктограммы

	Существуют и другие стили кнопок, такие как BS_FLAT,
	BS_LEFT, BS_MULTILINE, BS_NOTIFY, BS_PUSHLIKE, BS_RIGHT,
	BS_RIGHTBUTTON, BS_TEXT, BS_TOP, BS_VCENTER (см. встоенную
	справку)
	*/

	return TRUE;
}

// ****************************************************************
// Оконная процедура
// Получает очередное сообщение и индивидуально обрабатывает его
LRESULT CALLBACK WndProc(           // Возвращает результат
									//   обработки сообщения,
									//   зависящий от посланного
									//   сообщения: 0 - успех
	HWND                hwnd,       // Дескриптор созданного окна
	UINT                message,    // Номер сообщения
	WPARAM              wParam,     // Дополнительная информация о 
	LPARAM              lParam)    //   сообщении, зависящая от
								   //   типа сообщения (wParam,
								   //   lParam)
{
	// Обработчик сообщения - в данном случае приложение явно
	//   отвечает только на сообщения WM_DESTROY, WM_PAINT и
	//   WM_COMMAND от нажатия кнопки, все остальные сообщения
	//   передаются в DefWindowProc( ) - функцию, управляющую
	//   поведением окна по умолчанию. Обработка сообщений
	//   WM_DESTROY и WM_PAINT подробно рассмотрена в проекте
	//   FrameWnd
	switch (message)
	{
	case WM_PAINT:

		// Дескриптор контекста устройства
		HDC             hDC;
		// Указатель на структуру с информацией для приложения
		//   о клиентской области окна
		PAINTSTRUCT     ps;
		// Получение контекста устройства
		hDC = BeginPaint(hwnd, &ps);
		if (!hDC)
		{
			MessageBox(NULL, "Контекст устройства не получен",
				"Ошибка 2", MB_OK);
			exit(2);
		}
		// Вывод заданного текста
		if (!TextOut(hDC, 150, 0,
			"Обработка сообщения WM_PAINT", 28))
		{
			MessageBox(NULL, "Неверное использование TextOut",
				"Ошибка 3", MB_OK);
			exit(3);
		}
		// Освобождение контекста устройства
		if (!EndPaint(hwnd, &ps))
		{
			MessageBox(NULL, "Контекст устройства не освобожден",
				"Ошибка 4", MB_OK);
			exit(4);
		}
		break;

	case WM_DESTROY:

		// Указывает системе, что сделан запрос о завершении
		//   приложения: 0 - код завершения. Вызов этой функции
		//   обычно используется в ответ на поступившее
		//   сообщение WM_DESTROY 
		PostQuitMessage(0);
		break;

		// !!! Здесь будьте внимательнее - новая информация !!!
		// Сообщение WM_COMMAND генерируется очень большим
		//   количеством управляющих элементов (всевозможные
		//   кнопки, команды меню и т.п.). Для того, чтобы
		//   можно было правильно обработать конкретное
		//   сообщение WM_COMMAND, нужно знать, какой же из
		//   управляющих элементов создал сообщение. Информация
		//   об этом (идентификатор управляющего элемента)
		//   хранится в младшем слове параметра wParam и
		//   получить ее можно путем вызова макроса с
		//   параметром LOWORD( wParam )
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case BTN1:              // Нажата "Кнопка"

								// Звуковой сигнал
			if (!MessageBeep(MB_OK))
			{
				MessageBox(NULL, "Ошибка MessageBeep",
					"Ошибка 5", MB_OK);
				exit(5);
			}
			MessageBox(NULL, "Нажата кнопка", "Информация",
				MB_OK);
			// Обратите внимание, что вместо такой несложной
			//   обработки можно выполнить обработку любой
			//   сложности
		}
	}
	break;

	default:

		// Обработка сообщения по умолчанию
		return DefWindowProc(hwnd, message, wParam, lParam);

	}

	return 0;
}

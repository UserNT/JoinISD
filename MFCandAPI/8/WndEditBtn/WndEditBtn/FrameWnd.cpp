/*
Файл               : FrameWnd.cpp

Проект             : демонстрация созания Windows-приложения на
основе библиотеки классов MFC с кнопками в
главном окне, однострочным редактором и
выводом текста

Назначение         : реализация класса "FrameWnd", производного
от класса "CFrameWnd" библиотеки классов
MFC (обработка сообщений главного окна)

Microsoft Visual Studio C++ .NET 2005
*/

#include "StdAFX.h"                 // Прекомпилируемый файл
#include "FrameWnd.h"             // Объявление класса FrameWnd

// Идентификаторы управляющих элементов
#define IDC_BTNREAD 100             // Умалчиваемая кнопка "Чтение"
#define IDC_BTNEXIT 101             // Кнопка "Выход"
#define IDC_ECONE   102             // Однострочный редактор

// Определение таблицы сообщений
BEGIN_MESSAGE_MAP(FrameWnd, CFrameWnd)
	ON_COMMAND(IDC_BTNREAD, OnBtnReadClick)
	ON_COMMAND(IDC_BTNEXIT, OnBtnExitClick)
	ON_WM_PAINT()
END_MESSAGE_MAP()

// Конструктор умолчания (инициализация указателей на кнопки и
//   редактор)
FrameWnd::FrameWnd(void)
{
	m_pBtnRead = 0;
	m_pBtnExit = 0;
	m_pEdit = 0;
}

// Деструктор (освобождает память, занятую кнопками и однострочным
//   редактором)
FrameWnd :: ~FrameWnd(void)
{
	if (m_pBtnRead)
	{
		delete m_pBtnRead;
		m_pBtnRead = 0;
	}
	if (m_pBtnExit)
	{
		delete m_pBtnExit;
		m_pBtnExit = 0;
	}
	if (m_pEdit)
	{
		delete m_pEdit;
		m_pEdit = 0;
	}
}

// Создание дочерних управляющих элементов (перегружаемый
//   виртуальный метод)
void FrameWnd::CreateChildControls(void)
{
	// Размещаем в динамической памяти и создаем однострочный
	//   элемент редактирования
	m_pEdit = new CEdit;
	ASSERT_VALID(m_pEdit);        // Обработка ошибки размещения
	BOOL                rc = m_pEdit->Create(WS_VISIBLE |
		WS_CHILD | ES_LEFT | WS_BORDER, CRect(120, 20, 370, 40),
		this, IDC_ECONE);
	if (!rc)
	{
		TRACE0("\n Ошибка 2. Элемент редактирования не был"
			" создан \n");
		exit(2);
	}
	/*
	Первый аргумент в вызове метода Create( ) задает стиль окна
	редактирования.
	Имеются следующие стили объекта CEdit:
	ES_AUTOHSCROLL - автоматическое прокручивание текста вправо на
	10 символов при достижении правой границы окна
	(при нажатии клавиши ENTER текст
	прокручивается обратно в позицию 0);
	ES_AUTOVSCROLL - автоматическое прокручивание текста на одну
	страницу вверх в многострочном окне
	редактирования, когда пользователь нажимает
	ENTER в конце последней строки;
	ES_CENTER - выравнивает текст по центру в многострочном окне
	редактирования;
	ES_LEFT - выравнивает текст по левому краю;
	ES_LOWERCASE - по мере ввода автоматически трансформирует все
	символы в нижний регистр;
	ES_MULTILINE - задает многострочное окно редактирования
	(однострочное по умолчанию);
	ES_OEMCONVERT - поддерживает правильное преобразование символов
	в кодировку DOS;
	ES_PASSWORD - выводит в окно все введенные символы в виде *;
	ES_READONLY - не разрешает вводить или редактировать текст в
	окне;
	ES_RIGHT - выравнивает текст по правому краю;
	ES_UPPERCASE - по мере ввода автоматически трансформирует все
	символы в верхний регистр.
	Перечисленные особые стили редактирования можно сочетать с
	общими стилями окон, доступными объектам класса CWnd.
	*/
	m_pEdit->LimitText(20);       // Ограничение длины текста
								  // Начальная инициализация окна редактипования
	m_pEdit->SetWindowText("Длина текста <=20");
	/*
	Наряду с рассмотренными выше методами Create( ),
	LimitText( ), SetWindowText( ) существуют следующие методы,
	применимые для однострочных и многострочных окон
	редактирования:
	CanUndo( ) - определяет, может ли быть отменена операция
	редактирования;
	Clear( ) - удаляет выделенный текст, если он есть;
	Copy( ) - копирует выделенный текст, если он есть, в буфер
	обмена;
	Cut( ) - вырезает выделенный текст, если он есть, и помещает
	его в буфер обмена;
	EmtyUndoBuffer( ) - сбрасывает флаг отмены окна редактирования;
	DefFirstVisibleLine( ) - определяет верхнюю видимую строку в
	окне редактирования;
	GetModify( ) - определяет было ли изменено содержимое окна
	редактирования;
	GetPasswodChar( ) - возвращает символ-заменитель при вводе
	пароля;
	GetRect( ) - возвращает прямоугольник окна редактирования;
	GetSel( ) - возвращает позиции первого и последнего символов
	выделенного текста;
	LineFromChar( ) - возвращает номер строки, содержащей символ с
	указанным индексом;
	Linelength( ) - возвращает длину строки в окне редактирования;
	LineScroll( ) - прокручивает текст в многострочном окне
	редактирования;
	Paste( ) - вставляет данные из буфера обмена в текущую позицию
	курсора;
	ReplaceSel( ) - заменяет выделенный в окне редактирования текст
	указанным текстом;
	SetModify( ) - устанавливает или сбрасывает флаг изменения;
	SetPasswordChar( ) - назначает или удаляет символ-заменитель
	при вводе текста;
	SetReadOnly( ) - устанавливает режим доступа к окну
	редактирования "только для чтения";
	SetSel( ) - выбирает указанный диапазон символов в окне
	редактирования;
	Undo( ) - отменяет последнюю операцию редактирования.
	Кроме перечисленных, имеется ряд специфических методов
	многострочного окна редактирования.
	*/

	// Размещаем в динамической памяти и создаем кнопку "Чтение"
	//   (выбрана по умолчанию)
	m_pBtnRead = new CButton;
	ASSERT_VALID(m_pBtnRead);
	rc = m_pBtnRead->Create("Чтение", WS_VISIBLE | WS_CHILD |
		BS_DEFPUSHBUTTON, CRect(20, 20, 110, 40), this,
		IDC_BTNREAD);
	if (!rc)
	{
		TRACE0("\n Ошибка 3. Кнопка \"Чтение\" не была"
			" создана \n");
		exit(3);
	}

	// Размещаем в динамической памяти и создаем кнопку "Выход"
	m_pBtnExit = new CButton;
	ASSERT_VALID(m_pBtnExit);     // Обработка ошибки размещения
	rc = m_pBtnExit->Create("Выход", WS_VISIBLE | WS_CHILD
		| BS_PUSHBUTTON, CRect(424, 200, 513, 230), this,
		IDC_BTNEXIT);
	if (!rc)
	{
		TRACE0("\n Ошибка 4. Кнопка \"Выход\" не была"
			" создана \n");
		exit(4);
	}

	return;
}

// Обработчик кнопки "Чтение"
afx_msg void FrameWnd::OnBtnReadClick(void)
{
	// Звуковой сигнал
	BOOL                rc = MessageBeep(-1);
	if (!rc)
	{
		TRACE0("\n Ошибка 5. Неверное завершение MessageBeep \n");
		exit(5);
	}

	// Чтение и визуализация текста из однострочного редактора
	CString             string;        // Для прочитанного текста
	m_pEdit->GetWindowText(string);
	AfxMessageBox(string);

	return afx_msg void();
}

// Обработчик кнопки "Выход"
afx_msg void FrameWnd::OnBtnExitClick(void)
{
	BOOL                rc = MessageBeep(-1);
	if (!rc)
	{
		TRACE0("\n Ошибка 6. Неверное завершение MessageBeep \n");
		exit(6);
	}
	rc = DestroyWindow();
	if (!rc)
	{
		TRACE0("\n Ошибка 7. Окно не было разрушено \n");
		exit(7);
	}

	return afx_msg void();
}

// Обработчик сообщения WM_PAINT: демонстрирует вывод поясняющнго
//   текста
afx_msg void FrameWnd::OnPaint(void)
{
	// Создаем объект для рисования и вывода
	CPaintDC            PaintDC(this);

	// Вывод заданного текста (третий аргумент) в определенное
	//   место окна (первый и второй аргументы)
	PaintDC.TextOut(120, 0, "Однострочное окно редактирования");

	return afx_msg void();
}

/*
Файл               : FrameWnd.cpp

Проект             : демонстрация создания Windows-приложения
на основе библиотеки классов MFC,
выполняющего вывод в главное окно

Назначение         : реализация класса "FrameWnd", производного
от класса "CFrameWnd" библиотеки классов
MFC (обработка сообщений главного окна)

Microsoft Visual Studio C++ .NET 2005
*/

#include "StdAfx.h"                 // Прекомпилируемый файл
#include "FrameWnd.h"             // Объявление класса FrameWnd

// Определение таблицы сообщений
BEGIN_MESSAGE_MAP(FrameWnd, CFrameWnd)
	ON_WM_PAINT()
END_MESSAGE_MAP()
/*
!!! Обратите внимание на место расположения опеделения карты
сообщений!!!
Макрос DECLARE_MESSAGE_MAP, расположенный в конце объявления
класса LFramtWnd, применяется для объявления таблицы сообщений.
Структура карты сообщений достаточно проста и представляет собой
набор макросов, заключенных в специальные "операторные скобки".
Начинается карта сообщений с вызова макроса
BEGIN_MESSAGE_MAP( FrameWnd, CFrameWnd ), который имеет следующие
аргументы: FrameWnd - задает имя класса, который является
владельцем карты сообщений; CFrameWnd - определяет имя базового
класса. Заканчивается карта сообщений вызовом макроса
END_MESSAGE_MAP( ). Между этими двумя вызовами располагаются
специальные макросы, называемые компонентами карты сообщений. Вот
они-то, собственно, и позволяют сопоставить сообщение с конкретным
обработчиком.
Для каждого стандартного сообщения Windows определен свой макрос
в форме ON_WM_XXX, где XXX - имя сообщения, например, ON_WM_PAINT.
Имена обработчиков определяются при распаковке параметров каждого
сообщения Windows, на основе простого соглашения. Имена обработчиков
всегда начинаются с префикса On, за которым следует имя
соответствующего сообщения Windows (без префикса WM_), записанное
строчными буквами. Например, для сообщения WM_PAINT в классе CWnd
определен обработчик (см. в файле FrameWnd.hpp)
afx_msg void OnPaint( void );
Описания всех обработчиков стандартных сообщений Windows можно
найти в файле afxwin.h в объявлении класса CWnd.
Отметим также, что для командных сообщений Windows от меню,
акселераторов и кнопок панелей инструментов, для команд обновления,
для извещений, посылаемых дочерними окнами своим родителям, для
кнопок, элементов редактирования, списков и комбинированных списков
используются другие макросы. Они будут рассмотрены в последующих
проектах.
*/

// Обработчик сообщения WM_PAINT: демонстрирует задание различных
//   контекстов (перья, кисти, цвета, толщина пера, стиль закраски
//   кистью и др.)
afx_msg void FrameWnd::OnPaint(void)
{
	COLORREF            oldColor,   // Старый цвет символов
		oldBkColor; // Старый цвет фона символов
	CBrush              NewBrush,   // Новая кисть
		*OldBrush;  // Указатель на старую кисть
	CPen                NewPen,     // Новое перо
		*OldPen;    // Указатель на старое перо

					// Создаем объект для рисования и вывода
	CPaintDC            PaintDC(this);
	/*
	Рисовать очень удобно с помощью класса CPaintDC. Объект
	CPaintDC представляет поверхность окна. Чтобы отчетливо понять
	его назначение, напомним как выполняется рисование с
	использованием SDK-API-функций:
	// Дескриптор контекста устройства
	HDC                 hDC;
	// Указатель на структуру с информацией для приложения о
	//   клиентской области окна, используется для вывода в окно
	PAINTSTRUCT         ps;
	// Для любого вывода в окно Windows необходимо использовать
	//   функции GDI, которые в качестве параметра используют
	//   контекст устройства. Обычно контекст устройства получают с
	//   помощью фунции BeginPaint
	hDC = BeginPaint( hwnd, &ps );
	// Вывод заданного текста (четвертый аргумент, 28 - длина
	//   текста) в определенное место окна (второй и третий
	//   аргументы)
	TextOut( hDC, 150, 0, "Обработка сообщения WM_PAINT", 28 );
	// Вывод информации в окно завершается вызовом функции EndPaint
	//   (для каждого вызова BeginPaint должен существовать
	//   соответствующий вызов EndPaint)
	EndPaint( hwnd, &ps );
	Объект CPaintDC выполняет те же действия, но только
	абстрагирует их в класс MFC. Основные этапы использования
	объекта CPaintDC:
	1. Создание объекта CPaintDC.
	2. Рисование на объекте CPaintDC.
	3. Разрушение объекта CPaintDC.
	Конструктор CPaintDC вызывает функцию BeginPaint( ) и
	возвращает графический DC для рисования. Деструктор вызывает
	EndPaint( )
	*/

	// Вывод заданного текста (третий аргумент) в определенное
	//   место окна (первый и второй аргументы)
	PaintDC.TextOut(0, 0, "Текст с цветом умолчания");

	// Вывод заданного текста (третий аргумент) в определенное
	//   место окна (первый и второй аргументы). Перед выводом
	//   текста задается цвет символов (зеленый) и цвет фона
	//   (черный). После вывода текста восстанавливаются прежние
	//   значения указанных параметров. Здесь макрос RGB(0, 255, 0)
	//   задает тройку чисел, определяющих цвет - первое число
	//   определяет значение красной составляющей, второе - зеленой
	//   и третье - синей
	oldColor = PaintDC.SetTextColor(RGB(0, 255, 0));
	oldBkColor = PaintDC.SetBkColor(RGB(0, 0, 0));
	PaintDC.TextOut(250, 0, "Текст с изменением цвета");
	PaintDC.SetTextColor(oldColor);
	PaintDC.SetBkColor(oldBkColor);

	// Рисование линии: вначале выводится поясняющий текст
	//   (используется текущий цвет и фон), а затем - рисуется
	//   линия. Линия рисуется цветом текущего пера на текущем
	//   фоне. В функции MoveTo( ) (125, 50) - новая текущая
	//   позиция в окне. Функция LineTo( ) рисует линию из текущей
	//   позиции до точки (175, 100)
	PaintDC.TextOut(50, 30, "Пример вывода линии в окно");
	PaintDC.MoveTo(125, 50); PaintDC.LineTo(175, 100);

	// Рисование эллипса: вначале выводится поясняющий текст
	//   (используется текущий цвет и фон), а затем - рисуется
	//   эллипс. В функции Ellipse( ) (100, 140)  и (200, 240) - 
	//   координаты левого верхнего и правого нижнего углов
	//   прямоугольника, в который вписан эллипс. Эллипс рисуется
	//   существующим пером, а внутренняя область эллипса
	//   закрашивается новой кистью (красной). После рисования
	//   старая кисть восстанавливаются
	PaintDC.TextOut(50, 120, "Пример вывода эллипса в окно");
	// Создаем красную кисть
	NewBrush.CreateSolidBrush(RGB(255, 0, 0));
	// Включаем ее в контекст
	OldBrush = PaintDC.SelectObject(&NewBrush);
	PaintDC.Ellipse(100, 140, 200, 240);
	// Удаляем новую кисть
	NewBrush.DeleteObject();
	// Восстанавливаем старую кисть
	PaintDC.SelectObject(OldBrush);

	// Рисование прямоугольника: вначале выводится поясняющий
	//   текст, а затем - рисуется прямоугольник. Перед рисованием
	//   прямоугольника задаются параметры пера для рисования
	//   прямоугольника. В функции Rectangle( ) (370, 140)  и
	//   (470, 200) - координаты левого верхнего и правого нижнего
	//   углов прямоугольника. Прямоугольник закрашивается текущей
	//   кистью. После рисования старое перо восстанавливается
	PaintDC.TextOut(300, 120,
		"Пример вывода прямоугольника в окно");
	// Создаем новое перо: точечное, толщиной 1, красного цвета
	NewPen.CreatePen(PS_DOT, 1, RGB(255, 0, 0));
	// Включаем его в контекст
	OldPen = PaintDC.SelectObject(&NewPen);
	PaintDC.Rectangle(370, 140, 470, 200);
	// Удаляем новое перо
	NewPen.DeleteObject();
	// Восстанавливаем старое перо
	PaintDC.SelectObject(OldPen);

	return afx_msg void();
}
